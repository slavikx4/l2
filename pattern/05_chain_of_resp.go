package main

/*
	Реализовать паттерн «цепочка обязаностей».
Объяснить применимость паттерна, его плюсы и минусы,а также реальные примеры использования данного примера на практике.

Паттерн "Цепочка обязанностей" (Chain of Responsibility pattern) является поведенческим паттерном проектирования, который позволяет передавать запросы последовательно по цепочке обработчиков до тех пор, пока один из обработчиков не сможет обработать запрос.

Применимость паттерна "Цепочка обязанностей" возникает, когда у вас есть набор объектов, которые могут обрабатывать запросы, и вы хотите, чтобы запрос был автоматически перенаправлен от одного объекта к другому до тех пор, пока он не будет обработан или достигнет конца цепочки. Это может быть полезно, когда вы хотите добиться гибкости в обработке запросов и избежать жестких связей между отправителем запроса и получателем.

Плюсы использования паттерна "Цепочка обязанностей":

Разделение обязанностей: Паттерн позволяет разделить обязанности обработки запросов между различными объектами. Каждый объект в цепочке может быть ответственным за определенный аспект обработки и принимать решение о передаче запроса дальше или его обработке.

Гибкость и расширяемость: Цепочка обязанностей обеспечивает гибкость в добавлении новых обработчиков и изменении порядка обработки без изменения клиентского кода. Вы можете легко добавлять новые объекты в цепочку или изменять ее конфигурацию, чтобы отвечать на различные запросы.

Уменьшение связанности: Паттерн позволяет избежать жесткой связанности между отправителем запроса и получателем. Отправитель не нужно знать о конкретном получателе, а получатель не знает о предыдущих или последующих обработчиках в цепочке. Это уменьшает зависимости и делает систему более гибкой и расширяемой.

Минусы использования паттерна "Цепочка обязанностей":

Не гарантируется обработка запроса: Из-за отсутствия явной связи между отправителем и получателем запроса нет гарантии, что запрос будет обработан. Если ни один из обработчиков не может обработать запрос, он может быть проигнорирован или потерян.

Возможность бесконечной цепочки: Неправильная конфигурация цепочки может привести к бесконечному циклу обработки запросов или зацикливанию. Это может быть проблемой, если не управлять правильно логикой передачи запроса в цепочке.

Реальные примеры использования паттерна "Цепочка обязанностей" в Go можно найти во многих областях программирования. Вот несколько примеров:

Обработка HTTP-запросов: Веб-фреймворки на базе Go часто используют цепочку обязанностей для обработки HTTP-запросов. Каждый обработчик может проверять и обрабатывать определенные аспекты запроса, такие как аутентификация, авторизация, валидация данных и т.д.
*/

import "fmt"

type request string

type iHandler interface {
	process(*request)
	setNextHandle(iHandler)
}

type processRequest struct {
	handler iHandler
}

func (po *processRequest) process(r *request) {
	po.handler.process(r)
}

type concreteHandle1 struct {
	request
	next iHandler
}

func (ch1 *concreteHandle1) process(r *request) {
	if *r == ch1.request {
		fmt.Println("process first handler")
		return
	} else {
		ch1.next.process(r)
	}
}

func (ch1 *concreteHandle1) setNextHandle(h iHandler) {
	ch1.next = h
}

type concreteHandle2 struct {
	request
	next iHandler
}

func (ch2 *concreteHandle2) process(r *request) {
	if *r == ch2.request {
		fmt.Println("process second handler")
		return
	} else {
		ch2.next.process(r)
	}
}

func (ch2 *concreteHandle2) setNextHandle(h iHandler) {
	ch2.next = h
}

type concreteHandle3 struct {
	request
	next iHandler
}

func (ch3 *concreteHandle3) process(r *request) {
	if *r == ch3.request {
		fmt.Println("process three handler")
		return
	} else {
		ch3.next.process(r)
	}
}

func (ch3 *concreteHandle3) setNextHandle(h iHandler) {
	ch3.next = h
}

func main() {

	ch1 := &concreteHandle1{request: "first"}
	ch2 := &concreteHandle2{request: "second"}
	ch3 := &concreteHandle3{request: "three"}

	ch1.setNextHandle(ch2)
	ch2.setNextHandle(ch3)

	processOrder := &processRequest{handler: ch1}

	req := new(request)
	*req = "second"

	processOrder.process(req)
}
